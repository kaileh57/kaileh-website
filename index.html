<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Humanity's Last Exam Quiz</title>
    <!-- Add Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- COMPREHENSIVE MATHJAX CONFIGURATION -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEnvironments: true,
          processRefs: true,
          processEscapes: true,
          packages: {
            '[+]': ['base', 'ams', 'noerrors', 'noundefined', 'autoload', 'require', 'color', 
                   'colorv2', 'physics', 'mhchem', 'cancel', 'enclose', 'mathtools', 'boldsymbol']
          },
          tags: 'ams',
          useLabelIds: true,
          macros: {
            // Common macros for math notation
            'degreeC': '\\degree\\text{C}',
            'degree': '^{\\circ}',
            'R': '\\mathbb{R}',
            'N': '\\mathbb{N}',
            'Z': '\\mathbb{Z}',
            'C': '\\mathbb{C}',
            'Q': '\\mathbb{Q}',
            'inf': '\\inf',
            'sup': '\\sup',
            'where': '\\text{ where }',
            'such': '\\text{ such }',
            'that': '\\text{ that }',
            'and': '\\text{ and }',
            'for': '\\text{ for }',
            'with': '\\text{ with }',
            'we': '\\text{ we }',
            'have': '\\text{ have }',
            'if': '\\text{ if }',
            'then': '\\text{ then }',
            'otherwise': '\\text{ otherwise }',
            'iff': '\\text{ if and only if }',
            'mathcal': '\\mathcal',
            'hat': '\\hat',
            'bar': '\\bar',
            'tilde': '\\tilde',
            'vec': '\\vec',
            'bold': '\\bold',
            'overline': '\\overline',
            'underline': '\\underline',
            'implies': '\\implies',
            'iff': '\\iff',
            'forall': '\\forall',
            'exists': '\\exists',
            'epsilon': '\\epsilon',
            'theta': '\\theta',
            'gamma': '\\gamma',
            'lambda': '\\lambda',
            'delta': '\\delta',
            'alpha': '\\alpha',
            'beta': '\\beta',
            'sum': '\\sum',
            'prod': '\\prod',
            'lim': '\\lim',
            'int': '\\int',
            'oint': '\\oint',
            'times': '\\times',
            'cdot': '\\cdot',
            'pm': '\\pm',
            'mp': '\\mp',
            'le': '\\le',
            'ge': '\\ge',
            'neq': '\\neq',
            'approx': '\\approx',
            'equiv': '\\equiv',
            'subset': '\\subset',
            'supset': '\\supset',
            'in': '\\in',
            'notin': '\\notin',
            'cup': '\\cup',
            'cap': '\\cap',
            'emptyset': '\\emptyset',
            'partial': '\\partial',
            'nabla': '\\nabla',
            'infty': '\\infty',
            'therefore': '\\therefore',
            'because': '\\because'
          },
          environment: {
            enumerate: ['\\begin{enumerate}', '\\end{enumerate}'],
            itemize: ['\\begin{itemize}', '\\end{itemize}'],
            align: ['\\begin{align}', '\\end{align}'],
            matrix: ['\\begin{matrix}', '\\end{matrix}'],
            pmatrix: ['\\begin{pmatrix}', '\\end{pmatrix}'],
            bmatrix: ['\\begin{bmatrix}', '\\end{bmatrix}'],
            cases: ['\\begin{cases}', '\\end{cases}']
          }
        },
        // Enable additional packages
        loader: {
          load: [
            '[tex]/base',
            '[tex]/ams',
            '[tex]/autoload',
            '[tex]/color', 
            '[tex]/colorv2',
            '[tex]/physics', 
            '[tex]/mhchem', 
            '[tex]/cancel', 
            '[tex]/enclose', 
            '[tex]/mathtools',
            '[tex]/boldsymbol',
            '[tex]/require'
          ]
        },
        options: {
          enableMenu: true,
          renderActions: {
            addMenu: [], // remove the menu
            checkLoading: [] // remove the loading message
          }
        },
        startup: {
          ready: () => {
            // Fix some LaTeX environments manually
            const fixLaTeXEnvironments = () => {
              document.querySelectorAll('.question-text, .choice-content, .rationale').forEach(el => {
                let content = el.innerHTML;
                
                // Fix "Unknown environment" errors
                content = content.replace(/Unknown environment 'enumerate'/g, '');
                content = content.replace(/Unknown environment 'itemize'/g, '');
                
                // Replace LaTeX environments with HTML
                content = content.replace(/\\begin\{enumerate\}/g, '<ol>');
                content = content.replace(/\\end\{enumerate\}/g, '</ol>');
                content = content.replace(/\\begin\{itemize\}/g, '<ul>');
                content = content.replace(/\\end\{itemize\}/g, '</ul>');
                content = content.replace(/\\item/g, '<li>');
                content = content.replace(/\\item\[(.*?)\]/g, '<li>$1: ');
                
                // Close li tags that don't have closing tags
                const matches = content.match(/<li>.*?(?=<li>|<\/[ou]l>|$)/g);
                if (matches) {
                  matches.forEach(match => {
                    if (!match.includes('</li>')) {
                      content = content.replace(match, match + '</li>');
                    }
                  });
                }
                
                // Fix common LaTeX expressions
                content = content.replace(/\\degreeC/g, '째C');
                content = content.replace(/\\degree/g, '째');
                
                // Fix broken inline math delimiters
                content = content.replace(/([^$])(\$)([^$\s].*?[^$\s])(\$)([^$])/g, '$1$$$3$$$5');
                
                // Ensure display math has proper spacing
                content = content.replace(/\$\$/g, '\n$$\n');
                
                el.innerHTML = content;
              });
            };
            
            MathJax.startup.defaultReady();
            fixLaTeXEnvironments();
            MathJax.typesetPromise().catch(err => console.log('Typeset failed: ' + err.message));
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js"></script>
    
    <style>
    /* CSS Styles */
    :root {
      --primary: #4f46e5;
      --primary-light: #818cf8;
      --primary-dark: #3730a3;
      --secondary: #f97316;
      --background: #0f172a;
      --card-bg: #1e293b;
      --text: #f1f5f9;
      --text-light: #94a3b8;
      --border: #334155;
      --correct: #34d399;
      --correct-bg: #064e3b;
      --incorrect: #f87171;
      --incorrect-bg: #7f1d1d;
      --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2);
      --transition: all 0.3s ease;
      --radius: 8px;
    }

    /* Light theme variables */
    .light-theme {
      --primary: #4f46e5;
      --primary-light: #818cf8;
      --primary-dark: #3730a3;
      --secondary: #f97316;
      --background: #f8fafc;
      --card-bg: #ffffff;
      --text: #1e293b;
      --text-light: #64748b;
      --border: #e2e8f0;
      --correct: #10b981;
      --correct-bg: #d1fae5;
      --incorrect: #ef4444;
      --incorrect-bg: #fee2e2;
      --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      line-height: 1.6;
      color: var(--text);
      background-color: var(--background);
      transition: var(--transition);
    }

    .app {
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }

    /* Header Styles */
    header {
      margin-bottom: 30px;
    }

    .header-content {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 5px;
    }

    header h1 {
      font-size: 2.5rem;
      font-weight: 700;
      color: var(--primary);
      margin: 0;
    }

    .tagline {
      font-size: 1.1rem;
      color: var(--text-light);
      margin-bottom: 20px;
    }

    .theme-toggle {
      display: flex;
      align-items: center;
    }

    #theme-toggle-btn {
      background: none;
      border: none;
      color: var(--text);
      cursor: pointer;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: var(--transition);
    }

    #theme-toggle-btn:hover {
      background-color: var(--border);
    }

    .sun-icon, .moon-icon {
      width: 24px;
      height: 24px;
    }

    .sun-icon {
      display: none;
    }

    .moon-icon {
      display: block;
    }

    .light-theme .sun-icon {
      display: block;
    }

    .light-theme .moon-icon {
      display: none;
    }

    /* Stats Container */
    .stats-container {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-bottom: 20px;
    }

    .stat {
      background-color: var(--card-bg);
      border-radius: var(--radius);
      padding: 12px 20px;
      box-shadow: var(--shadow);
      flex: 1;
      min-width: 100px;
      text-align: center;
      transition: var(--transition);
    }

    .stat-label {
      display: block;
      font-size: 0.9rem;
      color: var(--text-light);
      margin-bottom: 5px;
    }

    .stat-value {
      display: block;
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--primary);
    }

    /* Category Filter */
    .category-filter {
      margin-bottom: 20px;
    }

    .category-filter label {
      display: block;
      margin-bottom: 5px;
      color: var(--text-light);
      font-size: 0.9rem;
    }

    #category-select {
      width: 100%;
      padding: 10px 15px;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background-color: var(--card-bg);
      color: var(--text);
      font-size: 1rem;
      transition: var(--transition);
    }

    /* Loading */
    .loading-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 40px;
    }

    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(255, 255, 255, 0.1);
      border-radius: 50%;
      border-top-color: var(--primary);
      animation: spin 1s ease-in-out infinite;
      margin-bottom: 20px;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    /* Card Styles */
    .question-card {
      background-color: var(--card-bg);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
      margin-bottom: 30px;
      transition: var(--transition);
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px;
      background-color: var(--primary);
      color: white;
    }

    .category-badge {
      font-weight: 600;
      font-size: 1rem;
      padding: 5px 10px;
      background-color: rgba(255, 255, 255, 0.2);
      border-radius: 20px;
    }

    .question-id {
      font-size: 0.9rem;
      opacity: 0.8;
    }

    .question-content {
      padding: 30px 20px;
      font-size: 1.1rem;
      border-bottom: 1px solid var(--border);
    }

    .question-text {
      margin-bottom: 20px;
      line-height: 1.8;
    }

    /* IMPROVED: Additional styling for LaTeX and lists */
    .question-text ol, .question-text ul, 
    .choice-content ol, .choice-content ul,
    .rationale ol, .rationale ul {
      margin-left: 2.5rem;
      margin-bottom: 1rem;
    }

    .question-text li, .choice-content li, .rationale li {
      margin-bottom: 0.5rem;
    }

    .question-text ol ol, .question-text ul ul,
    .choice-content ol ol, .choice-content ul ul,
    .rationale ol ol, .rationale ul ul {
      margin-top: 0.5rem;
      margin-bottom: 0.5rem;
    }

    /* Special styles for LaTeX math expressions */
    .mjx-math {
      padding: 0.1rem 0;
    }

    /* Bracket notation styling */
    .bracket-notation {
      font-weight: 600;
      display: inline-block;
      background-color: rgba(79, 70, 229, 0.1);
      padding: 0 0.3rem;
      border-radius: 3px;
      margin: 0 0.1rem;
    }

    .image-container {
      display: flex;
      justify-content: center;
      margin-top: 20px;
    }

    #question-image {
      max-width: 100%;
      max-height: 400px;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    }

    /* Answer Section Styles */
    .answer-section {
      padding: 20px;
    }

    .multiple-choice {
      margin-bottom: 20px;
    }

    /* IMPROVED: Better choice item layout */
    .choice-item {
      padding: 15px;
      margin-bottom: 12px;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      cursor: pointer;
      transition: var(--transition);
      background-color: var(--card-bg);
      word-wrap: break-word;
      overflow-wrap: break-word;
      display: flex;
      align-items: flex-start;
    }

    .choice-item:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow);
    }

    .choice-item.selected {
      border-color: var(--primary);
      background-color: rgba(79, 70, 229, 0.1);
    }

    .choice-item.correct {
      border-color: var(--correct);
      background-color: var(--correct-bg);
    }

    .choice-item.incorrect {
      border-color: var(--incorrect);
      background-color: var(--incorrect-bg);
    }

    /* IMPROVED: Choice letter and content styling */
    .choice-letter {
      font-weight: bold;
      min-width: 30px;
      margin-right: 10px;
      font-size: 1.1rem;
    }
    
    .choice-content {
      flex: 1;
    }
    
    /* Add styles for long or complex multiple choice options */
    .choice-item.long-option {
      flex-direction: column;
      align-items: flex-start;
      padding: 15px 15px 20px 15px;
    }
    
    .choice-item.long-option .choice-letter {
      margin-bottom: 10px;
    }
    
    .choice-item.long-option .choice-content {
      width: 100%;
      line-height: 1.6;
    }

    .text-answer {
      margin-bottom: 20px;
    }

    .text-answer label {
      display: block;
      margin-bottom: 10px;
      font-weight: 500;
      color: var(--text);
    }

    .input-group {
      display: flex;
      gap: 10px;
    }

    #answer-input {
      flex: 1;
      padding: 12px 15px;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      font-size: 1rem;
      background-color: var(--card-bg);
      color: var(--text);
      transition: var(--transition);
    }

    #answer-input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.2);
    }

    .btn {
      display: inline-block;
      padding: 12px 20px;
      background-color: var(--primary);
      color: white;
      border: none;
      border-radius: var(--radius);
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: var(--transition);
      text-align: center;
    }

    .btn:hover {
      background-color: var(--primary-dark);
      transform: translateY(-2px);
    }

    .btn:disabled {
      background-color: var(--text-light);
      cursor: not-allowed;
      transform: none;
    }

    .btn.secondary {
      background-color: transparent;
      border: 1px solid var(--primary);
      color: var(--primary);
    }

    .btn.secondary:hover {
      background-color: rgba(79, 70, 229, 0.1);
    }

    .btn.primary {
      background-color: var(--primary);
      color: white;
      width: 100%;
      margin-top: 15px;
    }

    /* Feedback Styles */
    .feedback {
      margin-top: 20px;
    }

    .result-message {
      font-size: 1.3rem;
      font-weight: 600;
      text-align: center;
      margin-bottom: 20px;
      padding: 15px;
      border-radius: var(--radius);
    }

    .result-message.correct {
      background-color: var(--correct-bg);
      color: var(--correct);
    }

    .result-message.incorrect {
      background-color: var(--incorrect-bg);
      color: var(--incorrect);
    }

    .correct-answer {
      margin-bottom: 20px;
      padding: 15px;
      background-color: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      font-size: 1.1rem;
    }

    .explanation-container {
      margin: 20px 0;
    }

    #show-explanation {
      width: 100%;
    }

    .explanation {
      margin: 15px 0;
      padding: 20px;
      background-color: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: var(--radius);
    }

    .explanation h3 {
      margin-bottom: 15px;
      color: var(--primary);
      font-weight: 600;
    }

    .rationale {
      line-height: 1.8;
      margin-bottom: 15px;
    }

    .author {
      margin-top: 15px;
      font-style: italic;
      font-size: 0.9rem;
      color: var(--text-light);
    }

    /* Error State */
    .error-message {
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      padding: 40px;
      background-color: var(--card-bg);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    }

    .error-message svg {
      width: 50px;
      height: 50px;
      color: var(--incorrect);
      margin-bottom: 20px;
    }

    .error-message p {
      margin-bottom: 20px;
      font-size: 1.1rem;
      color: var(--text);
    }

    #retry-btn {
      background-color: var(--primary);
    }

    /* Footer Styles */
    footer {
      text-align: center;
      margin-top: 30px;
      padding-top: 20px;
      border-top: 1px solid var(--border);
      color: var(--text-light);
      font-size: 0.9rem;
    }

    footer a {
      color: var(--primary);
      text-decoration: none;
      transition: var(--transition);
    }

    footer a:hover {
      text-decoration: underline;
      color: var(--primary-dark);
    }

    /* Responsive Styles */
    @media (max-width: 600px) {
      .app {
        padding: 15px;
      }
      
      header h1 {
        font-size: 2rem;
      }
      
      .stats-container {
        flex-direction: column;
        gap: 10px;
      }
      
      .stat {
        width: 100%;
      }
      
      .input-group {
        flex-direction: column;
      }
      
      .btn {
        width: 100%;
      }
    }

    /* Animation for transitions */
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .question-card {
      animation: fadeIn 0.3s ease-out;
    }

    /* New feature - Category tag list */
    .category-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 15px;
    }

    .category-tag {
      background-color: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 5px 12px;
      font-size: 0.85rem;
      cursor: pointer;
      transition: var(--transition);
    }

    .category-tag:hover {
      border-color: var(--primary);
      background-color: rgba(79, 70, 229, 0.1);
    }

    .category-tag.active {
      background-color: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    /* Add submit button for multiple choice */
    #multiple-choice-submit {
      display: block;
      width: 100%;
      margin-top: 20px;
    }

    /* Set a reasonable min-height for choice items */
    .choice-item {
      min-height: 60px;
      display: flex;
      align-items: flex-start;
    }
    </style>
</head>
<body>
    <div class="app">
        <header>
            <div class="header-content">
                <h1>Humanity's Last Exam</h1>
                <div class="theme-toggle">
                    <button id="theme-toggle-btn" aria-label="Toggle light mode">
                        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                            <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m-9-9H2m17 0h1M5.6 5.6l.7.7m12.1-.7l-.7.7m-12.1 11.4l.7-.7m12.1.7l-.7-.7M16 12a4 4 0 1 1-8 0 4 4 0 0 1 8 0z"/>
                        </svg>
                        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                            <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                        </svg>
                    </button>
                </div>
            </div>
            <p class="tagline">Test your knowledge with extremely challenging questions</p>
            
            <div class="stats-container">
                <div class="stat">
                    <span class="stat-label">Questions</span>
                    <span id="questions-count" class="stat-value">0</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Correct</span>
                    <span id="correct-count" class="stat-value">0</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Accuracy</span>
                    <span id="accuracy" class="stat-value">0%</span>
                </div>
            </div>
            
            <div class="category-filter">
                <label for="category-select">Filter by category:</label>
                <div class="category-tags" id="category-tags">
                    <!-- Popular categories will be shown as tags -->
                </div>
                <select id="category-select">
                    <option value="all">All Categories</option>
                    <!-- Categories will be populated by JavaScript -->
                </select>
            </div>
        </header>

        <main id="quiz-container">
            <div id="loading" class="loading-container">
                <div class="loading-spinner"></div>
                <p>Loading questions...</p>
            </div>
            
            <div id="question-card" class="question-card" style="display: none;">
                <div class="card-header">
                    <div class="category-badge" id="category">Category</div>
                    <div class="question-id" id="question-id">ID: 000</div>
                </div>
                
                <div class="question-content">
                    <div id="question-text" class="question-text">Question text will appear here</div>
                    <div id="image-container" class="image-container" style="display: none;">
                        <img id="question-image" alt="Question visual">
                    </div>
                </div>
                
                <div class="answer-section">
                    <div id="multiple-choice" class="multiple-choice" style="display: none;">
                        <!-- Multiple choice options will be populated here -->
                        <button id="multiple-choice-submit" class="btn" disabled>Submit Answer</button>
                    </div>
                    
                    <div id="text-answer" class="text-answer" style="display: none;">
                        <label for="answer-input">Your answer:</label>
                        <div class="input-group">
                            <input type="text" id="answer-input" placeholder="Type your answer here...">
                            <button id="submit-btn" class="btn" disabled>Submit</button>
                        </div>
                    </div>
                    
                    <div id="feedback" class="feedback" style="display: none;">
                        <div id="result-message" class="result-message"></div>
                        <div id="correct-answer" class="correct-answer"></div>
                        
                        <div class="explanation-container">
                            <button id="show-explanation" class="btn secondary">Show Explanation</button>
                            
                            <div id="explanation" class="explanation" style="display: none;">
                                <h3>Explanation:</h3>
                                <div id="rationale" class="rationale"></div>
                                <div id="author" class="author"></div>
                            </div>
                        </div>
                        
                        <button id="next-btn" class="btn primary">Next Question</button>
                    </div>
                </div>
            </div>
            
            <div id="error" class="error-message" style="display: none;">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                    <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/>
                </svg>
                <p>Failed to load questions. Make sure questions.json exists in the same directory.</p>
                <button id="retry-btn" class="btn">Retry</button>
            </div>
        </main>

        <footer>
            <p>Questions from <a href="https://huggingface.co/datasets/cais/hle" target="_blank">Humanity's Last Exam dataset</a> | <a href="https://github.com/centerforaisafety/HLE" target="_blank">GitHub</a></p>
        </footer>
    </div>

    <script>
    // State management without localStorage
    let questions = [];
    let currentQuestion = null;
    let seenQuestionIds = new Set();
    let userAnswer = '';
    let isAnswered = false;
    let questionsAnswered = 0;
    let correctAnswers = 0;
    let categoryStats = {};
    let categories = new Set();
    let selectedCategory = 'all';
    let popularCategories = [];
    
    // DOM Elements
    const loadingElement = document.getElementById('loading');
    const errorElement = document.getElementById('error');
    const questionCardElement = document.getElementById('question-card');
    const categoryElement = document.getElementById('category');
    const questionIdElement = document.getElementById('question-id');
    const questionTextElement = document.getElementById('question-text');
    const imageContainerElement = document.getElementById('image-container');
    const questionImageElement = document.getElementById('question-image');
    const multipleChoiceElement = document.getElementById('multiple-choice');
    const multipleChoiceSubmitElement = document.getElementById('multiple-choice-submit');
    const textAnswerElement = document.getElementById('text-answer');
    const answerInputElement = document.getElementById('answer-input');
    const submitButtonElement = document.getElementById('submit-btn');
    const feedbackElement = document.getElementById('feedback');
    const resultMessageElement = document.getElementById('result-message');
    const correctAnswerElement = document.getElementById('correct-answer');
    const showExplanationButtonElement = document.getElementById('show-explanation');
    const explanationElement = document.getElementById('explanation');
    const rationaleElement = document.getElementById('rationale');
    const authorElement = document.getElementById('author');
    const nextButtonElement = document.getElementById('next-btn');
    const questionsCountElement = document.getElementById('questions-count');
    const correctCountElement = document.getElementById('correct-count');
    const accuracyElement = document.getElementById('accuracy');
    const retryButtonElement = document.getElementById('retry-btn');
    const categorySelectElement = document.getElementById('category-select');
    const categoryTagsElement = document.getElementById('category-tags');
    const themeToggleButtonElement = document.getElementById('theme-toggle-btn');

    // Theme Management
    function initTheme() {
        // Use a variable in memory instead of localStorage
        window.darkTheme = true;
    }

    function toggleTheme() {
        window.darkTheme = !window.darkTheme;
        if (window.darkTheme) {
            document.body.classList.remove('light-theme');
        } else {
            document.body.classList.add('light-theme');
        }
    }

    // IMPROVED: Preprocess LaTeX in text
    function preprocessLaTeX(text) {
        if (!text) return '';
        
        let processed = text;
        
        // Fix common LaTeX issues
        processed = processed.replace(/Unknown environment 'enumerate'/g, '');
        processed = processed.replace(/Unknown environment 'itemize'/g, '');
        processed = processed.replace(/\\degreeC/g, '째C');
        processed = processed.replace(/\\degree/g, '째');
        
        // Replace problematic LaTeX environments with proper HTML
        processed = processed.replace(/\\begin\{enumerate\}/g, '<ol>');
        processed = processed.replace(/\\end\{enumerate\}/g, '</ol>');
        processed = processed.replace(/\\begin\{itemize\}/g, '<ul>');
        processed = processed.replace(/\\end\{itemize\}/g, '</ul>');
        processed = processed.replace(/\\item/g, '<li>');
        
        // Ensure list items are properly closed
        const liMatches = processed.match(/<li>.*?(?=<li>|<\/[ou]l>|$)/g);
        if (liMatches) {
            liMatches.forEach(match => {
                if (!match.includes('</li>')) {
                    processed = processed.replace(match, match + '</li>');
                }
            });
        }
        
        // Fix badly formatted inline math expressions
        processed = processed.replace(/([^$])(\$)([^$\s].*?[^$\s])(\$)([^$])/g, '$1$$$3$$$5');
        
        // Style bracket notation for choices
        processed = processed.replace(/\[([0-9,\s]+)\]/g, '<span class="bracket-notation">[$1]</span>');
        
        return processed;
    }

    // Fetch questions from local JSON file
    async function fetchQuestions() {
        try {
            showLoading();
            
            try {
                // Try to fetch questions.json first
                const response = await fetch('questions.json');
                if (!response.ok) {
                    throw new Error('questions.json not found');
                }
                const data = await response.json();
                processQuestions(data);
            } catch (error) {
                console.error('Error loading questions.json:', error);
                showError();
            }
        } catch (error) {
            console.error('Error in fetchQuestions:', error);
            showError();
        }
    }

    // Process questions data
    function processQuestions(data) {
        if (!Array.isArray(data) || data.length === 0) {
            showError();
            return;
        }
        
        questions = data;
        
        // Extract categories and count their occurrences
        const categoryCount = new Map();
        questions.forEach(q => {
            if (q.category) {
                categories.add(q.category);
                categoryCount.set(q.category, (categoryCount.get(q.category) || 0) + 1);
            }
        });
        
        // Get the most popular categories
        popularCategories = Array.from(categoryCount.entries())
            .sort((a, b) => b[1] - a[1])
            .slice(0, 5)
            .map(entry => entry[0]);
        
        // Populate category filter
        populateCategoryFilter();
        
        // Update stats display
        updateStatsDisplay();
        
        // Load random question
        loadRandomQuestion();
    }

    // Populate category filter dropdown and tags
    function populateCategoryFilter() {
        // Populate dropdown
        categorySelectElement.innerHTML = '<option value="all">All Categories</option>';
        
        // Add categories in alphabetical order
        Array.from(categories).sort().forEach(category => {
            const option = document.createElement('option');
            option.value = category;
            option.textContent = category;
            categorySelectElement.appendChild(option);
        });
        
        // Populate tags for popular categories
        categoryTagsElement.innerHTML = `
            <div class="category-tag ${selectedCategory === 'all' ? 'active' : ''}" data-category="all">All</div>
        `;
        
        popularCategories.forEach(category => {
            const tagElement = document.createElement('div');
            tagElement.className = `category-tag ${selectedCategory === category ? 'active' : ''}`;
            tagElement.dataset.category = category;
            tagElement.textContent = category;
            categoryTagsElement.appendChild(tagElement);
        });
        
        // Add event listeners to category tags
        const categoryTags = categoryTagsElement.querySelectorAll('.category-tag');
        categoryTags.forEach(tag => {
            tag.addEventListener('click', () => {
                selectedCategory = tag.dataset.category;
                categorySelectElement.value = selectedCategory;
                
                // Update active state
                categoryTags.forEach(t => t.classList.remove('active'));
                tag.classList.add('active');
                
                loadRandomQuestion();
            });
        });
    }

    // Load a random question based on selected category
    function loadRandomQuestion() {
        if (questions.length === 0) {
            showError();
            return;
        }

        // Filter questions by selected category
        let filteredQuestions = questions;
        if (selectedCategory !== 'all') {
            filteredQuestions = questions.filter(q => q.category === selectedCategory);
            
            // If no questions in this category, revert to all categories
            if (filteredQuestions.length === 0) {
                filteredQuestions = questions;
                selectedCategory = 'all';
                categorySelectElement.value = 'all';
            }
        }

        // Find questions that haven't been seen yet
        let unseenQuestions = filteredQuestions.filter(q => !seenQuestionIds.has(q.id));
        
        // If all questions have been seen, reset the seen questions set
        if (unseenQuestions.length === 0) {
            seenQuestionIds = new Set();
            unseenQuestions = filteredQuestions;
        }
        
        // Pick a random unseen question
        const randomIndex = Math.floor(Math.random() * unseenQuestions.length);
        currentQuestion = unseenQuestions[randomIndex];
        seenQuestionIds.add(currentQuestion.id);
        
        displayQuestion();
        resetAnswer();
    }

    // IMPROVED: Display the current question with better handling of LaTeX and content
    function displayQuestion() {
        // Hide loading and error, show question card
        hideLoading();
        hideError();
        showQuestionCard();
        
        // Set question details
        categoryElement.textContent = currentQuestion.category || 'Uncategorized';
        questionIdElement.textContent = `ID: ${currentQuestion.id}`;
        
        // Preprocess and set question text
        const processedQuestion = preprocessLaTeX(currentQuestion.question);
        questionTextElement.innerHTML = processedQuestion;
        
        // Handle image if present
        if (currentQuestion.image) {
            const imagePath = `images/${currentQuestion.image}`;
            const imagePathPng = imagePath.replace(/\.(jpg|jpeg)$/, '.png');
            
            // Try PNG first
            questionImageElement.src = imagePathPng;
            
            questionImageElement.onerror = () => {
                // If PNG fails, try JPG or original extension
                questionImageElement.src = imagePath;
                
                questionImageElement.onerror = () => {
                    console.log('Image failed to load:', imagePath);
                    imageContainerElement.style.display = 'none';
                };
            };
            
            questionImageElement.onload = () => {
                imageContainerElement.style.display = 'flex';
            };
            
            // Initially show the container, it will be hidden if the image fails to load
            imageContainerElement.style.display = 'flex';
        } else {
            imageContainerElement.style.display = 'none';
        }
        
        // Handle answer type with improved multiple choice handling
        if (currentQuestion.answer_type === 'multipleChoice') {
            displayMultipleChoice();
            textAnswerElement.style.display = 'none';
        } else {
            multipleChoiceElement.style.display = 'none';
            textAnswerElement.style.display = 'block';
        }
        
        // Scroll to the top of the question
        questionCardElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
        
        // Render LaTeX
        renderMathJax();
    }

    // IMPROVED: Advanced choice parser function with better handling of array notation
    function parseChoicesFromQuestion(questionText) {
        if (!questionText) return null;
        
        // First try: Find choices after "Answer Choices:" label
        if (questionText.includes('Answer Choices:')) {
            const parts = questionText.split('Answer Choices:');
            if (parts.length >= 2) {
                const choicesText = parts[1].trim();
                
                // First try to extract lettered options with bracket notation [1], [2,3], etc.
                const letterBracketPattern = /([A-Z])\.\s*\[([0-9,\s]+)\]/g;
                const letterBracketMatches = Array.from(choicesText.matchAll(letterBracketPattern));
                
                if (letterBracketMatches && letterBracketMatches.length > 0) {
                    return letterBracketMatches.map(match => 
                        `${match[1]}. [${match[2].trim()}]`
                    );
                }
                
                // Try regular lettered options (A., B., C.)
                const letterPattern = /([A-Z])\.\s*((?:(?!\s[A-Z]\.).)+)/gs;
                const letterMatches = Array.from(choicesText.matchAll(letterPattern));
                
                if (letterMatches && letterMatches.length > 0) {
                    return letterMatches.map(match => 
                        `${match[1]}. ${match[2].trim()}`
                    );
                }
                
                // Try Roman numeral options or combinations
                const romanPattern = /([A-Z])\.\s*([IVX,\s]+)/gs;
                const romanMatches = Array.from(choicesText.matchAll(romanPattern));
                
                if (romanMatches && romanMatches.length > 0) {
                    return romanMatches.map(match => 
                        `${match[1]}. ${match[2].trim()}`
                    );
                }
            }
        }
        
        // Second try: Look for options at the end of question matching bracket pattern
        const bracketOptionsMatch = questionText.match(/([A-Z])\.[\s]*\[([0-9,\s]+)\]/g);
        if (bracketOptionsMatch && bracketOptionsMatch.length > 0) {
            return bracketOptionsMatch.map(option => option.trim());
        }
        
        // Third try: Split by letter followed by period
        const letterOptionsMatch = questionText.match(/([A-Z])\.[\s]*(.*?)(?=\s[A-Z]\.|$)/gs);
        if (letterOptionsMatch && letterOptionsMatch.length > 0) {
            return letterOptionsMatch.map(option => option.trim());
        }
        
        // Final fallback: Create generic options
        return ['A. Option A', 'B. Option B', 'C. Option C', 'D. Option D'];
    }

    // IMPROVED: Enhanced brackets formatting
    function formatBracketNotation(text) {
        if (!text) return '';
        return text.replace(/\[([0-9,\s]+)\]/g, '<span class="bracket-notation">[$1]</span>');
    }

    // IMPROVED: Display multiple choice options with better formatting for arrays and complex options
    function displayMultipleChoice() {
        // Clear the container but keep or recreate the submit button
        multipleChoiceElement.innerHTML = '';
        const submitButton = document.createElement('button');
        submitButton.id = 'multiple-choice-submit';
        submitButton.className = 'btn';
        submitButton.disabled = true;
        submitButton.textContent = 'Submit Answer';
        submitButton.addEventListener('click', checkAnswer);
        
        // Parse choices from question if not present
        if (!Array.isArray(currentQuestion.choices) || currentQuestion.choices.length === 0) {
            const parsedChoices = parseChoicesFromQuestion(currentQuestion.question);
            if (parsedChoices && parsedChoices.length > 0) {
                currentQuestion.choices = parsedChoices;
            } else {
                // Create basic choice set if parsing failed
                currentQuestion.choices = ['A. Option A', 'B. Option B', 'C. Option C', 'D. Option D'];
            }
        }
        
        // Process each choice option
        const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        currentQuestion.choices.forEach((choice, index) => {
            if (!choice || typeof choice !== 'string') return;
            
            const choiceItem = document.createElement('div');
            choiceItem.className = 'choice-item';
            
            // Extract letter and content
            let letter, content;
            
            // Try to match patterns like "A. [1, 2]" or "A. Some text"
            const letterMatch = choice.match(/^([A-Z])\.\s*(.*)/i);
            if (letterMatch && letterMatch.length > 2) {
                letter = letterMatch[1].toUpperCase();
                content = letterMatch[2].trim();
            } else {
                // Fallback: Use index to determine letter
                letter = alphabet[index];
                content = choice.trim();
            }
            
            // Check if this is a complex or long choice
            const isComplex = content.length > 100 || 
                               content.includes('\n') || 
                               content.includes('$') || 
                               content.includes('[');
            
            if (isComplex) {
                choiceItem.classList.add('long-option');
            }
            
            // Save letter for answer checking
            choiceItem.dataset.value = letter;
            
            // Create letter element
            const letterElement = document.createElement('div');
            letterElement.className = 'choice-letter';
            letterElement.textContent = letter + '.';
            
            // Create and format content element
            const contentElement = document.createElement('div');
            contentElement.className = 'choice-content';
            
            // Format bracket notation for array answers like [1, 2, 3]
            contentElement.innerHTML = formatBracketNotation(preprocessLaTeX(content));
            
            // Add elements to the choice item
            choiceItem.appendChild(letterElement);
            choiceItem.appendChild(contentElement);
            
            // Add click event for selection
            choiceItem.addEventListener('click', () => {
                if (!isAnswered) {
                    // Clear previous selections
                    const selectedChoices = multipleChoiceElement.querySelectorAll('.selected');
                    selectedChoices.forEach(selected => selected.classList.remove('selected'));
                    
                    // Select this choice
                    choiceItem.classList.add('selected');
                    userAnswer = letter;
                    
                    // Enable submit button
                    submitButton.disabled = false;
                }
            });
            
            // Add to container
            multipleChoiceElement.appendChild(choiceItem);
        });
        
        // Add submit button
        multipleChoiceElement.appendChild(submitButton);
        multipleChoiceElement.style.display = 'block';
    }

    // IMPROVED: Process complex answer formats including array notation
    function processAnswer(answerText) {
        if (!answerText) return '';
        
        // Handle array notation [1, 2, 3] in answers
        const bracketMatch = answerText.match(/^\[([0-9,\s]+)\]$/);
        if (bracketMatch) {
            return bracketMatch[0]; // Return the full bracket notation
        }
        
        // Handle answers that start with a letter (A., B., etc.)
        const letterMatch = answerText.match(/^([A-Z])\.\s*.*$/);
        if (letterMatch) {
            return letterMatch[1]; // Return just the letter
        }
        
        return answerText;
    }

    // Reset answer state
    function resetAnswer() {
        userAnswer = '';
        isAnswered = false;
        
        // Reset input field
        answerInputElement.value = '';
        answerInputElement.disabled = false;
        
        // Reset submit buttons
        submitButtonElement.disabled = true;
        submitButtonElement.style.display = 'block';
        const multipleChoiceSubmitBtn = document.getElementById('multiple-choice-submit');
        if (multipleChoiceSubmitBtn) multipleChoiceSubmitBtn.disabled = true;
        if (multipleChoiceSubmitBtn) multipleChoiceSubmitBtn.style.display = 'block';
        
        // Hide feedback
        feedbackElement.style.display = 'none';
        explanationElement.style.display = 'none';
        
        // Reset explanation button text
        showExplanationButtonElement.textContent = 'Show Explanation';

        // Focus the answer input (for text answers)
        if (textAnswerElement.style.display !== 'none') {
            setTimeout(() => {
                answerInputElement.focus();
            }, 300);
        }
    }

    // Check the user's answer
    function checkAnswer() {
        if (!currentQuestion) return;
        
        let correct = false;
        
        if (currentQuestion.answer_type === 'multipleChoice') {
            // For multiple choice, normalize answer format
            const processedUserAnswer = processAnswer(userAnswer).trim().toUpperCase();
            const processedCorrectAnswer = processAnswer(currentQuestion.answer).trim().toUpperCase();
            
            // Special handling for array notation
            if (processedUserAnswer === processedCorrectAnswer) {
                correct = true;
            } else if (processedUserAnswer.startsWith('[') && processedCorrectAnswer.startsWith('[')) {
                // Extract numbers from bracket notation and compare
                const userNums = processedUserAnswer.replace(/[\[\]\s]/g, '').split(',').sort().join(',');
                const correctNums = processedCorrectAnswer.replace(/[\[\]\s]/g, '').split(',').sort().join(',');
                correct = userNums === correctNums;
            }
        } else {
            const normalizedUserAnswer = userAnswer.trim().toLowerCase();
            const normalizedCorrectAnswer = currentQuestion.answer.toLowerCase();
            correct = normalizedUserAnswer === normalizedCorrectAnswer;
        }
        
        isAnswered = true;
        questionsAnswered++;
        if (correct) {
            correctAnswers++;
            
            // Update category stats
            const category = currentQuestion.category || 'Uncategorized';
            categoryStats[category] = categoryStats[category] || { total: 0, correct: 0 };
            categoryStats[category].total = (categoryStats[category].total || 0) + 1;
            categoryStats[category].correct = (categoryStats[category].correct || 0) + 1;
        } else {
            // Update category stats for incorrect answers
            const category = currentQuestion.category || 'Uncategorized';
            categoryStats[category] = categoryStats[category] || { total: 0, correct: 0 };
            categoryStats[category].total = (categoryStats[category].total || 0) + 1;
        }
        
        // Update stats display
        updateStatsDisplay();
        
        // Display feedback
        showFeedback(correct);
    }

    // Update stats display
    function updateStatsDisplay() {
        questionsCountElement.textContent = questionsAnswered;
        correctCountElement.textContent = correctAnswers;
        const accuracy = questionsAnswered > 0 ? Math.round((correctAnswers / questionsAnswered) * 100) : 0;
        accuracyElement.textContent = `${accuracy}%`;
    }

    // Show feedback after answering
    function showFeedback(isCorrect) {
        // Hide submit buttons
        submitButtonElement.style.display = 'none';
        const multipleChoiceSubmitBtn = document.getElementById('multiple-choice-submit');
        if (multipleChoiceSubmitBtn) multipleChoiceSubmitBtn.style.display = 'none';
        
        // Disable input
        answerInputElement.disabled = true;
        
        // Show feedback
        feedbackElement.style.display = 'block';
        
        // Set result message
        resultMessageElement.textContent = isCorrect ? 'Correct!' : 'Incorrect!';
        resultMessageElement.className = isCorrect ? 'result-message correct' : 'result-message incorrect';
        
        // Format and set correct answer with special handling for bracket notation
        let formattedAnswer = preprocessLaTeX(currentQuestion.answer);
        formattedAnswer = formatBracketNotation(formattedAnswer);
        correctAnswerElement.innerHTML = `<strong>Correct answer:</strong> ${formattedAnswer}`;
        
        // Set rationale with preprocessing
        rationaleElement.innerHTML = preprocessLaTeX(currentQuestion.rationale) || 'No explanation provided.';
        
        // Set author if available
        if (currentQuestion.author_name) {
            authorElement.textContent = `Question by: ${currentQuestion.author_name}`;
            authorElement.style.display = 'block';
        } else {
            authorElement.style.display = 'none';
        }
        
        // Highlight correct answer for multiple choice
        if (currentQuestion.answer_type === 'multipleChoice') {
            const choices = multipleChoiceElement.querySelectorAll('.choice-item');
            const correctAnswer = processAnswer(currentQuestion.answer).toUpperCase();
            
            choices.forEach(choice => {
                if (choice.dataset.value.toUpperCase() === correctAnswer.toUpperCase()) {
                    choice.classList.add('correct');
                } else if (choice.classList.contains('selected')) {
                    choice.classList.add('incorrect');
                }
            });
        }
        
        // Render LaTeX in feedback
        renderMathJax();
    }

    // Enhanced MathJax rendering function
    function renderMathJax() {
        if (window.MathJax) {
            try {
                // Tell MathJax to typeset the entire document
                window.MathJax.typesetPromise()
                    .then(() => {
                        console.log('MathJax typesetting complete');
                    })
                    .catch((err) => {
                        console.error('MathJax typesetting failed:', err);
                    });
            } catch (error) {
                console.error('Error rendering MathJax:', error);
            }
        } else {
            console.warn('MathJax not loaded yet');
            // Try again in a moment
            setTimeout(renderMathJax, 500);
        }
    }

    // Show/hide UI elements
    function showLoading() {
        loadingElement.style.display = 'flex';
        errorElement.style.display = 'none';
        questionCardElement.style.display = 'none';
    }

    function hideLoading() {
        loadingElement.style.display = 'none';
    }

    function showError() {
        loadingElement.style.display = 'none';
        errorElement.style.display = 'flex';
        questionCardElement.style.display = 'none';
    }

    function hideError() {
        errorElement.style.display = 'none';
    }

    function showQuestionCard() {
        questionCardElement.style.display = 'block';
    }

    // Initialize everything
    document.addEventListener('DOMContentLoaded', () => {
        // Initialize theme
        initTheme();
        
        // Fetch questions when page loads
        fetchQuestions();
        
        // Listen for text input changes
        answerInputElement.addEventListener('input', (event) => {
            userAnswer = event.target.value.trim();
            submitButtonElement.disabled = userAnswer === '';
        });
        
        // Submit button click
        submitButtonElement.addEventListener('click', () => {
            checkAnswer();
        });
        
        // Enter key in text input
        answerInputElement.addEventListener('keypress', (event) => {
            if (event.key === 'Enter' && userAnswer.trim() !== '') {
                checkAnswer();
            }
        });
        
        // Show/hide explanation
        showExplanationButtonElement.addEventListener('click', () => {
            if (explanationElement.style.display === 'none') {
                explanationElement.style.display = 'block';
                showExplanationButtonElement.textContent = 'Hide Explanation';
            } else {
                explanationElement.style.display = 'none';
                showExplanationButtonElement.textContent = 'Show Explanation';
            }
        });
        
        // Next question button
        nextButtonElement.addEventListener('click', () => {
            loadRandomQuestion();
        });
        
        // Retry button
        retryButtonElement.addEventListener('click', () => {
            fetchQuestions();
        });
        
        // Category filter change
        categorySelectElement.addEventListener('change', (event) => {
            selectedCategory = event.target.value;
            
            // Update category tags
            const categoryTags = categoryTagsElement.querySelectorAll('.category-tag');
            categoryTags.forEach(tag => {
                tag.classList.toggle('active', tag.dataset.category === selectedCategory);
            });
            
            loadRandomQuestion();
        });
        
        // Theme toggle
        themeToggleButtonElement.addEventListener('click', () => {
            toggleTheme();
        });
        
        // Add keypress shortcuts
        document.addEventListener('keydown', (event) => {
            // Press 'n' for next question when feedback is shown
            if (event.key === 'n' && feedbackElement.style.display === 'block') {
                loadRandomQuestion();
            }
            
            // Press 'e' to toggle explanation when feedback is shown
            if (event.key === 'e' && feedbackElement.style.display === 'block') {
                showExplanationButtonElement.click();
            }
        });
    });
    </script>
</body>
</html>